{% extends "base.html" %}
{% load static %}

{% block title %}{{ form_title }} - QuizPy{% endblock %}

{% block content %}
<h1>{{ form_title }}</h1>
<hr>

{# Form Submission Feedback Placeholders #}
<div id="errorMessage" class="alert alert-danger d-none" role="alert"></div>
<div id="successMessage" class="alert alert-success d-none" role="alert"></div>

{# Loading indicator (for edit mode primarily) #}
<div id="loadingSpinner" class="text-center my-5 d-none">
    <div class="spinner-border text-primary" role="status"><span class="visually-hidden">Loading...</span></div>
    <p>Loading question details...</p>
</div>

<form id="questionForm" class="d-none"> {# Initially hidden until JS decides create/edit loaded #}
    {% csrf_token %}
    <input type="hidden" id="questionId" value="{{ question_id|default:'' }}">

    {# templates/teacher_interface/question_edit_form.html #}

    {# --- Core Question Fields --- #}
    <div class="row mb-3">
        <div class="col-md-8">
            <label for="questionText" class="form-label">Question Text <span class="text-danger">*</span></label>
            <textarea class="form-control" id="questionText" rows="4" required></textarea>
            {# Placeholder for potential Rich Text Editor integration later #}
        </div>
        <div class="col-md-4">
            <label for="questionType" class="form-label">Question Type <span class="text-danger">*</span></label>
            <select class="form-select" id="questionType" required>
                <option value="" selected disabled>Select type...</option>
                <option value="MCQ">Multiple Choice (Single/Multiple Correct)</option>
                <option value="SHORT_TEXT">Short Text Answer</option>
                {# <option value="MEDIA">Media Based (Not Implemented)</option> #}
            </select>
        </div>
    </div>

    {# --- Dynamic Section based on Type --- #}
    <div id="mcqOptionsSection" class="mb-3 border p-3 rounded d-none">
        <div class="d-flex justify-content-between align-items-center mb-2">
            <h5 class="mb-0">Multiple Choice Options</h5>
            {# --- ADDED Checkbox --- #}
            <div class="form-check form-switch">
                <input class="form-check-input" type="checkbox" role="switch" id="mcqSingleChoice">
                <label class="form-check-label" for="mcqSingleChoice">Single Correct Answer Only</label>
            </div>
            {# --- END ADDED --- #}
        </div>
        <div id="mcqOptionsContainer">
            {# Option input groups will be added here by JS #}
        </div>
        <button type="button" class="btn btn-sm btn-outline-secondary mt-2" id="addMcqOptionBtn">
            <i class="bi bi-plus-circle"></i> Add Option
        </button>
        <small id="mcqInstruction" class="d-block mt-1 text-muted">Select the checkbox(es) for the correct
            answer(s).</small>
    </div>

    <div id="shortTextSection" class="mb-3 border p-3 rounded d-none">
        <h5>Short Text Answer</h5>
        <p class="text-muted"><small>Answers will be stored as entered by the student.</small></p>

        <div class="mb-3">
            <label class="form-label d-block">Review Mode:</label>
            <div class="form-check form-check-inline">
                {# --- Remove checked here --- #}
                <input class="form-check-input review-mode-radio" type="radio" name="shortAnswerReviewMode"
                    id="reviewModeManual" value="manual">
                <label class="form-check-label" for="reviewModeManual">Manual Review</label>
            </div>
            <div class="form-check form-check-inline">
                {# --- Add checked here --- #}
                <input class="form-check-input review-mode-radio" type="radio" name="shortAnswerReviewMode"
                    id="reviewModeAuto" value="auto" checked>
                <label class="form-check-label" for="reviewModeAuto">Automatic Review</label>
            </div>
        </div>

        <div id="correctAnswerInputGroup" class="mb-3 d-none"> {# Initially hidden #}
            <label for="shortAnswerCorrectText" class="form-label">Correct Answer Text <span
                    class="text-danger">*</span></label>
            <input type="text" class="form-control" id="shortAnswerCorrectText"
                placeholder="Enter the exact correct answer">
            <small class="text-muted">Case-sensitive matching will be used.</small>
        </div>
    </div>

    <div id="mediaSection" class="mb-3 border p-3 rounded d-none">
        <h5>Media (Placeholder)</h5>
        <p class="text-muted"><small>Functionality to upload/link media not yet implemented.</small></p>
        <input type="text" class="form-control" id="mediaUrl" placeholder="Enter Media URL (future)" disabled>
    </div>
    {# --- End Dynamic Section --- #}


    {# --- Additional Attributes --- #}
    <div class="row mb-3">
        <div class="col-md-4">
            <label for="questionScore" class="form-label">Score/Points</label>
            <input type="number" class="form-control" id="questionScore" value="1" min="0">
        </div>
        <div class="col-md-4">
            <label for="questionDifficulty" class="form-label">Difficulty</label>
            <select class="form-select" id="questionDifficulty">
                <option value="Easy">Easy</option>
                <option value="Medium" selected>Medium</option>
                <option value="Hard">Hard</option>
            </select>
        </div>
        <div class="col-md-4">
            <label for="questionCategory" class="form-label">Category/Tag</label>
            <input type="text" class="form-control" id="questionCategory" placeholder="e.g., Algebra, History Ch.3">
            {# Consider using datalist with existing_categories if passed from view #}
        </div>
    </div>

    <hr>
    <div class="d-flex justify-content-end">
        {# TODO: Determine correct cancel destination (Dashboard? Question Bank?) #}
        <a href="{% url 'teacher_interface:dashboard' %}" class="btn btn-secondary me-2">Cancel</a>
        <button type="submit" class="btn btn-primary" id="saveButton">
            <span class="spinner-border spinner-border-sm d-none" role="status" aria-hidden="true"
                id="saveSpinner"></span>
            <span id="saveButtonText">Save Question</span>
        </button>
    </div>
</form>

{% endblock %}


{% block extra_scripts %}
{{ block.super }}
<script>
    // --- DOM Elements ---
    const questionId = document.getElementById('questionId').value;
    const questionForm = document.getElementById('questionForm');
    const questionText = document.getElementById('questionText');
    const questionType = document.getElementById('questionType');
    const mcqOptionsSection = document.getElementById('mcqOptionsSection');
    const mcqOptionsContainer = document.getElementById('mcqOptionsContainer');
    const addMcqOptionBtn = document.getElementById('addMcqOptionBtn');


    const shortTextSection = document.getElementById('shortTextSection');
    const reviewModeRadios = document.querySelectorAll('.review-mode-radio'); // Select all radio buttons

    const correctAnswerInputGroup = document.getElementById('correctAnswerInputGroup');
    const shortAnswerCorrectText = document.getElementById('shortAnswerCorrectText');

    const mediaSection = document.getElementById('mediaSection');
    const questionScore = document.getElementById('questionScore');
    const questionDifficulty = document.getElementById('questionDifficulty');
    const questionCategory = document.getElementById('questionCategory');
    const mediaUrlInput = document.getElementById('mediaUrl'); // Added

    const errorMessageDiv = document.getElementById('errorMessage');
    const successMessageDiv = document.getElementById('successMessage');
    const saveButton = document.getElementById('saveButton');
    const saveButtonText = document.getElementById('saveButtonText');
    const saveSpinner = document.getElementById('saveSpinner');
    const loadingSpinner = document.getElementById('loadingSpinner');

    const mcqSingleChoiceSwitch = document.getElementById('mcqSingleChoice');
    const mcqInstructionSmall = document.getElementById('mcqInstruction'); // Get instruction text


    // --- Event Listeners ---
    questionType.addEventListener('change', handleQuestionTypeChange);
    addMcqOptionBtn.addEventListener('click', function () { // Wrap call in anonymous function
        addMcqOptionInput(); // Call without arguments
    });
    questionForm.addEventListener('submit', handleFormSubmit);
    mcqOptionsContainer.addEventListener('click', handleOptionDelete); // Listener for deleting options

    reviewModeRadios.forEach(radio => { // Add listener for radio buttons
        radio.addEventListener('change', toggleCorrectAnswerInput);
    });

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        if (questionId) {
            // Edit Mode
            saveButtonText.textContent = 'Update Question';
            showLoadingSpinner(true);
            fetchQuestionDetails(questionId);
        } else {
            // Create Mode
            handleQuestionTypeChange(); // Show/hide sections based on default "" type (i.e., hide all)
            showFormContent(true); // Show the form immediately
        }
    });

    mcqSingleChoiceSwitch.addEventListener('change', handleSingleChoiceChange);
    // Need to listen for changes on the *correct answer checkboxes* as well
    mcqOptionsContainer.addEventListener('change', handleCorrectAnswerChange);



    // --- Core Logic Functions ---

    // Handle change on the "Single Choice" switch
    function handleSingleChoiceChange() {
        const isSingle = mcqSingleChoiceSwitch.checked;
        const correctCheckboxes = mcqOptionsContainer.querySelectorAll('.correct-answer-checkbox');

        // Update instruction text
        mcqInstructionSmall.textContent = isSingle
            ? 'Select the radio button for the single correct answer.' // Change instructions
            : 'Select the checkbox(es) for the correct answer(s).';

        // Change input type and potentially uncheck others if switching to single
        let firstCheckedFound = false;
        correctCheckboxes.forEach(cb => {
            const wasChecked = cb.checked;
            // Change type: radio for single, checkbox for multiple
            cb.type = isSingle ? 'radio' : 'checkbox';
            // Ensure checkboxes have unique names if multiple allowed, shared name if radio
            cb.name = isSingle ? `mcq_correct_answer_${cb.closest('.input-group').dataset.optionId}` : `mcq_correct_answer_check_${cb.closest('.input-group').dataset.optionId}`; // Might need better naming if radios need group name

            // If switching TO single choice, only allow one to remain checked
            if (isSingle && wasChecked) {
                if (firstCheckedFound) {
                    cb.checked = false; // Uncheck subsequent ones
                }
                firstCheckedFound = true;
            }
        });
        // Ensure correct name attribute for radio buttons
        if (isSingle) {
            const radioButtons = mcqOptionsContainer.querySelectorAll('input[type="radio"].correct-answer-checkbox');
            const uniqueGroupName = `mcq_correct_group_${Date.now()}`; // Use unique name for radio group
            radioButtons.forEach(rb => rb.name = uniqueGroupName);
        }

        // Re-validate correct answer count after change
        validateCorrectAnswerCount();
    }

    // NEW: Handle clicking a correct answer checkbox/radio
    function handleCorrectAnswerChange(event) {
        if (!event.target.classList.contains('correct-answer-checkbox')) return; // Only handle these inputs

        const isSingle = mcqSingleChoiceSwitch.checked;
        const targetCheckbox = event.target;

        // If single choice mode (radios), clicking one automatically unchecks others - no extra logic needed.
        // If multiple choice mode (checkboxes), allow multiple selections.

        // Re-validate after any change
        validateCorrectAnswerCount();
    }

    // NEW: Validate correct answer count based on single/multi mode
    function validateCorrectAnswerCount() {
        const isSingle = mcqSingleChoiceSwitch.checked;
        const checkedCheckboxes = mcqOptionsContainer.querySelectorAll('.correct-answer-checkbox:checked');

        clearMessages(); // Clear previous errors
        let isValid = true;
        if (isSingle && checkedCheckboxes.length > 1) {
            showError("Single choice mode allows only one correct answer. Please unselect extras.");
            isValid = false;
            // Optionally, force unchecking others here, but letting user fix is clearer
        } else if (isSingle && checkedCheckboxes.length === 0) {
            // Allow zero while editing, check on submit
        } else if (!isSingle && checkedCheckboxes.length === 0) {
            // Allow zero while editing, check on submit
        }

        // Reflect validation state visually? Maybe border color? (Optional)
        // console.log("DEBUG: Correct answer count validation:", isValid);
        return isValid;
    }



    function toggleCorrectAnswerInput() {
        const autoModeSelected = document.getElementById('reviewModeAuto').checked;
        if (autoModeSelected) {
            correctAnswerInputGroup.classList.remove('d-none');
            shortAnswerCorrectText.required = true; // Make required if auto
        } else {
            correctAnswerInputGroup.classList.add('d-none');
            shortAnswerCorrectText.required = false; // Not required if manual
            shortAnswerCorrectText.value = ''; // Clear value when hiding
        }
    }

    function handleQuestionTypeChange() {
        const selectedType = questionType.value;
        // Hide all dynamic sections first
        mcqOptionsSection.classList.add('d-none');
        shortTextSection.classList.add('d-none');
        mediaSection.classList.add('d-none');

        // Show the relevant section
        if (selectedType === 'MCQ') {
            mcqOptionsSection.classList.remove('d-none');
            // Ensure at least a few options exist if empty (on type change in create mode)
            if (mcqOptionsContainer.childElementCount === 0 && !questionId) {
                addMcqOptionInput();
                addMcqOptionInput();
            }
        } else if (selectedType === 'SHORT_TEXT') {
            shortTextSection.classList.remove('d-none');
            toggleCorrectAnswerInput(); // Also check radio state when type changes to Short Text
        } else if (selectedType === 'MEDIA') {
            mediaSection.classList.remove('d-none');
        }
    }

    function addMcqOptionInput(optionText = '', isCorrect = false, optionId = null) {
        const isSingle = mcqSingleChoiceSwitch.checked; // Check current mode
        const inputType = isSingle ? 'radio' : 'checkbox';
        const uniqueGroupName = isSingle ? mcqOptionsContainer.querySelector('input[type=radio]')?.name || `mcq_correct_group_${Date.now()}` : ''; // Get existing radio group name or create new
        const inputName = isSingle ? uniqueGroupName : `mcq_correct_answer_check_${optionId || Date.now()}`; // Unique name for checkbox
        const optionIndex = mcqOptionsContainer.childElementCount;

        const div = document.createElement('div');

        div.classList.add('input-group', 'mb-2');
        // Use optionId if provided (from edit mode), otherwise it's just for client-side structure
        div.dataset.optionId = optionId || `temp_${optionIndex}`;

        div.innerHTML = `
            <div class="input-group-text">
                <input class="form-check-input mt-0 correct-answer-checkbox"
                    type="${inputType}"
                    name="${inputName}"
                    value="${optionId || 'new'}" {# Value might need linking to option ID #}
                    aria-label="Mark as correct answer" ${isCorrect ? 'checked' : ''}>
            </div>
            <input type="text" class="form-control mcq-option-text" value="${escapeHTML(optionText)}" placeholder="Enter answer option..." required>
            <button class="btn btn-outline-danger delete-option-btn" type="button" title="Remove option">
                <i class="bi bi-x-lg"></i>
            </button>
        `;
        mcqOptionsContainer.appendChild(div);
        // If adding first radio, ensure name is set on subsequent adds
        if (isSingle && mcqOptionsContainer.querySelectorAll('input[type=radio]').length === 1) {
            mcqOptionsContainer.querySelector('input[type=radio]').name = uniqueGroupName;
        }
    }


    function handleOptionDelete(event) {
        // If the delete button (or its icon) was clicked
        if (event.target.closest('.delete-option-btn')) {
            // Prevent deleting if only one option remains? Or allow? Let's allow for now.
            event.target.closest('.input-group').remove();
        }
    }


    async function fetchQuestionDetails(id) {
        try {
            const apiUrl = `/api/questions/${id}/`;
            const response = await fetch(apiUrl); // GET request

            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

            const data = await response.json();
            if (data.question) {
                populateForm(data.question);
                handleQuestionTypeChange(); // Ensure correct sections are shown after populating type
                showFormContent(true);
            } else {
                throw new Error("Question data not found in API response.");
            }
        } catch (error) {
            console.error("Failed to load question details:", error);
            showError(`Failed to load question details. ${error.message}`);
            showFormContent(false);
        } finally {
            showLoadingSpinner(false);
        }
    }

    function populateForm(qData) {
        questionText.value = qData.text || '';
        questionType.value = qData.type || '';
        questionScore.value = qData.score || 1;
        questionDifficulty.value = qData.difficulty || 'Medium';
        questionCategory.value = qData.category || '';
        mediaUrlInput.value = qData.media_url || '';
        mcqSingleChoiceSwitch.checked = qData.mcq_is_single_choice || false; // <<< Populate checkbox


        // Populate Short Text fields if applicable
        if (qData.type === 'SHORT_TEXT') {
            const reviewMode = qData.short_answer_review_mode || 'manual';
            document.getElementById(reviewMode === 'auto' ? 'reviewModeAuto' : 'reviewModeManual').checked = true;
            shortAnswerCorrectText.value = qData.short_answer_correct_text || '';
            // Call toggle AFTER setting radio button state
            toggleCorrectAnswerInput();
        } else {
            // Reset short text fields if type is not short text
            document.getElementById('reviewModeManual').checked = true;
            shortAnswerCorrectText.value = '';
            toggleCorrectAnswerInput();
        }

        // Populate MCQ options if applicable
        mcqOptionsContainer.innerHTML = '';
        if (qData.type === 'MCQ' && qData.options) {
            qData.options.forEach(option => {
                const isCorrect = qData.correct_answer?.includes(option.id);
                addMcqOptionInput(option.text, isCorrect, option.id); // addMcqOptionInput now respects switch state
            });
        }

        // Ensure correct state after population
        handleSingleChoiceChange(); // Set correct input types and instruction text
    }


    async function handleFormSubmit(event) {
        event.preventDefault();
        clearMessages();
        showSavingSpinner(true);

        // --- Collect Common Data ---
        const type = questionType.value;
        const text = questionText.value;
        const score = questionScore.value;
        const difficulty = questionDifficulty.value;
        const category = questionCategory.value;
        const mediaUrl = mediaUrlInput.value; // Added

        if (!text || !type) {
            showError("Question Text and Type are required.");
            showSavingSpinner(false);
            return;
        }

        // --- Prepare Payload ---
        const payload = { text, type, score, difficulty, category, media_url: mediaUrl };

        // --- Collect Type-Specific Data ---
        // --- Collect Type-Specific Data ---
        if (type === 'MCQ') {
            const options = [];
            const correctAnswers = []; // Still collect TEXTS for backend
            const optionGroups = mcqOptionsContainer.querySelectorAll('.input-group');
            const isSingle = mcqSingleChoiceSwitch.checked;
            payload.mcq_is_single_choice = isSingle; // <<< Include flag in payload

            // Basic validation
            if (optionGroups.length < 2) { /* ... error ... */ return; }

            let correctCount = 0;
            optionGroups.forEach(group => {
                const optionTextInput = group.querySelector('.mcq-option-text');
                const optionText = optionTextInput.value.trim();
                const correctInput = group.querySelector('.correct-answer-checkbox'); // Checkbox or Radio

                if (optionText) {
                    options.push(optionText);
                    if (correctInput.checked) {
                        correctAnswers.push(optionText);
                        correctCount++;
                    }
                }
            });

            // Final validation before submit
            if (options.length < 2) { /* ... error ... */ return; }
            if (isSingle && correctCount !== 1) {
                showError("Please select exactly one correct answer for single-choice MCQ.");
                showSavingSpinner(false); return;
            }
            if (!isSingle && correctCount === 0) {
                showError("Please select at least one correct answer for multiple-choice MCQ.");
                showSavingSpinner(false); return;
            }

            payload.options = options;
            payload.correct_answer_texts = correctAnswers;

        } else if (type === 'SHORT_TEXT') {
            const reviewMode = document.querySelector('input[name="shortAnswerReviewMode"]:checked').value;
            const correctText = shortAnswerCorrectText.value.trim();

            payload.short_answer_review_mode = reviewMode;
            if (reviewMode === 'auto') {
                if (!correctText) {
                    showError("Correct Answer Text is required for Automatic Review mode.");
                    showSavingSpinner(false);
                    return;
                }
                payload.short_answer_correct_text = correctText;
            }
            // else: no need to send correct_text if mode is manual

            // No specific fields needed for payload based on API-2
        } else if (type === 'MEDIA') {
            // Payload already includes media_url
            // Add validation if needed (e.g., check if URL is present)
        }

        // --- Determine API Endpoint and Method ---
        let apiUrl;
        let apiMethod;
        if (questionId) {
            apiUrl = `/api/questions/${questionId}/`;
            apiMethod = 'PUT';
        } else {
            apiUrl = "{% url 'quiz:question_list_create' %}"; // Use named URL for create
            apiMethod = 'POST';
            // TODO: How to associate with a quiz if needed?
            // Maybe pass quiz_id in payload if coming from quiz edit page?
            // payload.quiz_ids = ["TARGET_QUIZ_ID_IF_APPLICABLE"];
        }

        // --- Send API Request ---
        try {
            const csrfToken = questionForm.querySelector('[name=csrfmiddlewaretoken]').value;
            const response = await fetch(apiUrl, {
                method: apiMethod,
                headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                body: JSON.stringify(payload)
            });
            const data = await response.json();

            if (response.ok) {
                const successMsg = questionId ? 'Question updated successfully!' : 'Question created successfully!';
                showSuccess(successMsg + " Redirecting...");
                // Redirect (e.g., to dashboard or question bank TCHR-4)
                setTimeout(() => {
                    window.location.href = "{% url 'teacher_interface:dashboard' %}"; // Redirect to dashboard for now
                }, 1500);
            } else {
                showError(data.error || `An error occurred (${response.status})`);
                showSavingSpinner(false);
            }
        } catch (error) {
            console.error('Error saving question:', error);
            showError('An unexpected error occurred while saving.');
            showSavingSpinner(false);
        }
    }


    // --- Helper Functions (keep from previous steps) ---
    function showSavingSpinner(show) { /* ... */ }
    function showError(message) { /* ... */ }
    function showSuccess(message) { /* ... */ }
    function clearMessages() { /* ... */ }
    function showLoadingSpinner(show) { /* ... */ }
    function showFormContent(show) { /* ... */ }
    function escapeHTML(str) { /* ... */ } // Ensure this is defined

    // Copy implementations for helper functions from previous step
    function showSavingSpinner(show) {
        saveButton.disabled = show;
        if (show) {
            saveSpinner.classList.remove('d-none');
            saveButtonText.classList.add('visually-hidden');
        } else {
            saveSpinner.classList.add('d-none');
            saveButtonText.classList.remove('visually-hidden');
        }
    }
    function showError(message) {
        errorMessageDiv.textContent = message;
        errorMessageDiv.classList.remove('d-none');
    }
    function showSuccess(message) {
        successMessageDiv.textContent = message;
        successMessageDiv.classList.remove('d-none');
    }
    function clearMessages() {
        errorMessageDiv.classList.add('d-none');
        errorMessageDiv.textContent = '';
        successMessageDiv.classList.add('d-none');
        successMessageDiv.textContent = '';
    }
    function showLoadingSpinner(show) {
        if (show) { loadingSpinner.classList.remove('d-none'); }
        else { loadingSpinner.classList.add('d-none'); }
    }
    function showFormContent(show) {
        if (show) { questionForm.classList.remove('d-none'); }
        else { questionForm.classList.add('d-none'); }
    }
    function escapeHTML(str) {
        if (str === null || str === undefined) return '';
        const div = document.createElement('div');
        div.appendChild(document.createTextNode(str));
        return div.innerHTML;
    }

</script>
{% endblock %}