{{% extends "base.html" %} {# Or a simpler student base template if you created one #}
{% load static %}

{% block title %}Taking Quiz - QuizPy{% endblock %}

{% block extra_head %}
{{ block.super }} {# Includes base template's extra_head content #}
{# Add Bootstrap Icons if not already in base.html block #}
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">

<style>
    /* Ensure body/html have height for potentially sticky footer if base template uses it */
    /* Base body adjustments */
    html,
    body {
        height: 100%;
    }

    body {
        padding-top: 150px;
        /* Adjust as needed based on final header height */
        background-color: #f8f9fa;
        /* Lighter, slightly blue-ish background */
        color: #2c3e50;
        /* Darker default text */
    }

    /* Sticky Header - Improved styling */
    #quizHeader {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 1020;
        background-color: #ffffff;
        /* Clean white */
        border-bottom: 1px solid #e9ecef;
        padding: 1.5rem 0;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        /* Softer shadow */
    }

    #quizHeader .container-header {
        max-width: 900px;
        margin-left: auto;
        margin-right: auto;
        padding-left: 15px;
        padding-right: 15px;
    }

    #quizHeader h4 {
        font-size: 1.25rem;
        color: #2c3e50;
        font-weight: 600;
        margin-bottom: 1.5rem;
    }

    /* Slightly muted title color */
    #quizTimer {
        font-size: 3.5rem;
        font-weight: 900;
        color: #2c3e50;
        min-width: 160px;
        text-align: right;
        line-height: 1;
        transition: all 0.3s ease-in-out;
        position: relative;
        padding: 1rem 1.5rem;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 1.5rem;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        animation: float 3s ease-in-out infinite;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        letter-spacing: 1px;
        margin-top: 0.5rem;
        margin-bottom: 2rem;
    }

    @keyframes float {
        0% {
            transform: translateY(0px);
        }
        50% {
            transform: translateY(-8px);
        }
        100% {
            transform: translateY(0px);
        }
    }

    #quizTimer.text-danger {
        color: #dc3545 !important;
        animation: pulse 1s ease-in-out infinite;
        text-shadow: 2px 2px 4px rgba(220, 53, 69, 0.2);
    }

    @keyframes pulse {
        0% {
            transform: scale(1);
        }
        50% {
            transform: scale(1.08);
        }
        100% {
            transform: scale(1);
        }
    }

    #quizTimer.text-warning {
        color: #ffc107 !important;
        animation: shake 0.5s ease-in-out infinite;
        text-shadow: 2px 2px 4px rgba(255, 193, 7, 0.2);
    }

    @keyframes shake {
        0%, 100% {
            transform: translateX(0);
        }
        25% {
            transform: translateX(-8px);
        }
        75% {
            transform: translateX(8px);
        }
    }

    #quizTimer::before {
        content: '';
        position: absolute;
        top: -3px;
        left: -3px;
        right: -3px;
        bottom: -3px;
        background: linear-gradient(45deg, #0d6efd, #0dcaf0);
        border-radius: 1.6rem;
        z-index: -1;
        opacity: 0.3;
        transition: opacity 0.3s ease-in-out;
        filter: blur(8px);
    }

    #quizTimer.text-danger::before {
        background: linear-gradient(45deg, #dc3545, #ff6b6b);
        opacity: 0.4;
    }

    #quizTimer.text-warning::before {
        background: linear-gradient(45deg, #ffc107, #ff9800);
        opacity: 0.4;
    }

    #quizTimer::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0));
        border-radius: 1.5rem;
        pointer-events: none;
    }

    /* Slightly different red */
    #quizHeader .progress {
        height: 6px;
        border-radius: 3px;
        background-color: #e9ecef;
        margin-bottom: 0.5rem;
    }

    #quizHeader .progress-bar {
        background-color: #0d6efd;
        transition: width 0.3s ease-in-out;
    }

    /* Thinner, rounded progress bar */
    #studentInfoDisplay {
        font-size: 0.875rem;
        color: #6c757d;
        margin-top: 0.5rem;
    }

    /* Muted student info */

    /* Main quiz container */
    #quizContainer {
        max-width: 800px;
        margin-left: auto;
        margin-right: auto;
        padding-top: 2rem;
        /* More space below header */
        padding-bottom: 2rem;
    }

    /* Question Card Styling */
    .question-card {
        margin-bottom: 2rem;
        /* More space between questions */
        border: none;
        /* Remove default card border */
        border-radius: 0.75rem;
        /* Softer corners */
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        /* More pronounced shadow */
        background-color: #ffffff;
        transition: transform 0.2s ease-in-out;
    }

    .question-card:hover {
        transform: translateY(-2px);
    }

    .question-card .card-body {
        padding: 1.75rem;
        /* More padding inside card */
    }

    .question-card .card-title {
        color: #2c3e50;
        /* Darker blue-grey for question title */
        font-weight: 600;
        margin-bottom: 1.5rem !important;
        font-size: 1.25rem;
    }

    .question-text {
        font-weight: normal;
        /* Make actual question text less bold */
        color: #495057;
        line-height: 1.6;
    }

    .question-media img {
        max-height: 250px;
        /* Keep max height */
        border-radius: 0.5rem;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    /* --- MCQ Option Layout Fix & Styling --- */
    .question-options {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
    }

    .question-options .list-group-item {
        /* For TEXT options */
        display: flex;
        /* Use flexbox */
        align-items: center;
        /* Vertically align items */
        padding: 1rem 1.25rem;
        /* Adjust padding */
        border: 1px solid #e9ecef;
        border-radius: 0.5rem;
        background-color: #ffffff;
        cursor: pointer;
        transition: all 0.2s ease-in-out;
    }

    .question-options .list-group-item:hover {
        background-color: #f8f9fa;
        border-color: #dee2e6;
    }

    .question-options .list-group-item:first-child {
        border-top: 1px solid #e9ecef;
    }

    .question-options .list-group-item input[type="checkbox"],
    .question-options .list-group-item input[type="radio"] {
        margin-right: 1rem;
        cursor: pointer;
    }

    .question-options .mcq-option-image-item {
        /* Container for IMAGE options */
        display: flex;
        align-items: center;
        gap: 1rem;
        padding: 0.75rem;
        border: 1px solid #e9ecef;
        border-radius: 0.5rem;
        background-color: #ffffff;
        cursor: pointer;
    }

    .question-options .mcq-option-image-item label {
        display: flex;
        align-items: center;
        gap: 1rem;
        width: 100%;
        cursor: pointer;
        margin: 0;
    }

    .question-options .mcq-option-image {
        width: 120px;
        height: 80px;
        object-fit: cover;
        border-radius: 0.375rem;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .question-options .option-text {
        flex: 1;
        font-size: 0.95rem;
        color: #495057;
        line-height: 1.4;
    }

    .question-options .mcq-option-image-item input.mcq-option {
        position: absolute;
        /* Hide the input visually */
        opacity: 0;
        width: 0;
        height: 0;
        pointer-events: none;
        /* Make it unclickable directly */
    }

    .mcq-option-image-item.border-primary {
        border-color: #0d6efd !important;
        background-color: #e7f1ff;
    }

    /* Short Text Area */
    .short-text-answer {
        margin-top: 0.75rem;
        border-radius: 0.5rem;
        border: 1px solid #dee2e6;
        padding: 0.75rem;
        transition: border-color 0.2s ease-in-out;
    }

    .short-text-answer:focus {
        border-color: #0d6efd;
        box-shadow: 0 0 0 0.2rem rgba(13, 110, 253, 0.25);
    }

    /* Navigation Buttons */
    .quiz-nav-buttons {
        /* Add a wrapper div if needed for alignment */
        padding: 1.5rem 0;
    }

    .btn-lg {
        padding: 0.75rem 1.5rem;
        font-size: 1.1rem;
        border-radius: 0.5rem;
    }

    .btn-outline-secondary {
        border-color: #dee2e6;
        color: #495057;
    }

    .btn-outline-secondary:hover {
        background-color: #f8f9fa;
        border-color: #dee2e6;
        color: #2c3e50;
    }

    .btn-primary {
        background-color: #0d6efd;
        border-color: #0d6efd;
    }

    .btn-primary:hover {
        background-color: #0b5ed7;
        border-color: #0a58ca;
    }

    .btn-success {
        background-color: #198754;
        border-color: #198754;
    }

    .btn-success:hover {
        background-color: #157347;
        border-color: #146c43;
    }

    /* Optional: Hide base template navbar/footer for focus */
    /*
        nav.navbar.navbar-expand-lg, footer.footer {
             display: none !important;
        }
        body { padding-top: 150px !important; } // Adjust padding if navbar hidden
        */
</style>
{% endblock %}


{% block content %}
{# Main container for the whole quiz taking UI #}

{# Loading State - Shown initially, hidden by JS #}
<div id="quizLoading" class="text-center my-5">
    <div class="spinner-border text-primary" role="status"><span class="visually-hidden">Loading Quiz...</span></div>
    <p class="mt-2">Loading Quiz...</p>
</div>

{# Error State - Shown if JS encounters critical error #}
<div id="quizError" class="container mt-4 alert alert-danger d-none" style="max-width: 800px;">
    Error loading quiz data. Please try starting again.
</div>


{# --- STICKY HEADER --- #}
<div id="quizHeader">
    <div class="container-header"> {# Inner container for alignment & max-width #}
        {# Top Row: Title and Timer #}
        <div class="d-flex justify-content-between align-items-center mb-2 flex-wrap">
            <h4 id="quizTitle" class="mb-0 me-3 text-primary">Quiz Title</h4> {# Quiz Title Placeholder #}
            <div id="quizTimer" class="" style="display: none;">00:00</div> {# Timer display - initially hidden #}
        </div>
        {# Bottom Row: Progress Bar and Student Info #}
        <div>
            <div class="d-flex justify-content-between mb-1 small text-muted">
                <span>Progress</span>
                <span id="progressText">Question X of Y</span> {# Progress Text Placeholder #}
            </div>
            <div class="progress" style="height: 8px;">
                <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%;" aria-valuenow="0"
                    aria-valuemin="0" aria-valuemax="100"></div> {# Progress Bar #}
            </div>
            <div id="studentInfoDisplay" class="mt-1 text-muted">Student(s): Loading...</div> 
        </div>
    </div>
</div>
{# --- END STICKY HEADER --- #}


{# Main Quiz Content Area - Hidden initially until loading complete #}
{# Note: No margin-top needed as body padding handles space below header #}
{# --- Main Quiz Container --- #}
<div id="quizContainer" class="container d-none">
    {# Question Display Area #}
    <div id="questionArea">
        {# JS RENDERS CONTENT HERE #}
    </div>

    {# Navigation Area #}
    {# Consider wrapping in a div for consistent padding/margin #}
    <div class="d-flex justify-content-between mt-4 mb-5 quiz-nav-buttons">
        <button id="prevButton" class="btn btn-outline-secondary btn-lg" style="display: none;"> {# Style change #}
            <i class="bi bi-arrow-left"></i> Previous
        </button>
        <div id="navSpacer" class="flex-grow-1" style="display: none;"></div>
        <button id="nextButton" class="btn btn-primary btn-lg" style="display: none;"> {# Initially hidden if one-by-one
            #}
            Next <i class="bi bi-arrow-right"></i>
        </button>
        <button id="submitButton" class="btn btn-success btn-lg" style="display: none;">
            <span class="spinner-border spinner-border-sm d-none me-1" role="status" aria-hidden="true"></span>
            <i class="bi bi-check-circle-fill"></i>
            Submit Quiz
        </button>
    </div>
</div> {# End Quiz Container #}

{# Navigation Buttons Area #}
<div class="d-flex justify-content-between mt-4 mb-5">
    <button id="prevButton" class="btn btn-secondary btn-lg" style="display: none;">
        <i class="bi bi-arrow-left"></i> Previous
    </button>
    {# Add spacer div to push next/submit right when prevButton is hidden #}
    <div id="navSpacer" class="flex-grow-1" style="display: none;"></div>
    <button id="nextButton" class="btn btn-primary btn-lg" style="display: none;">
        Next <i class="bi bi-arrow-right"></i>
    </button>
    <button id="submitButton" class="btn btn-success btn-lg" style="display: none;">
        <span class="spinner-border spinner-border-sm d-none me-1" role="status" aria-hidden="true"></span>
        <i class="bi bi-check-circle-fill"></i>
        Submit Quiz
    </button>
</div>

</div> {# End Quiz Container #}

{% endblock %}


{% block extra_scripts %}
{{ block.super }} {# Includes base template's extra_scripts content #}


<script>
    // --- Constants ---
    const quizId = "{{ quiz_id }}"; // Get quiz ID from Django context
    const LOCAL_STORAGE_KEY_PREFIX = 'quizState_';

    // --- State Variables ---
    let quizData = null;                // Holds the structure of the quiz {id, title, config, questions:[{id, text, type, options?, media_url?}]}
    let studentInfo = null;             // Holds { name, class, id }
    let currentQuestionIndex = 0;       // Index of the currently displayed question (for one-by-one)
    let studentAnswers = {};            // Stores answers as { questionId: answerValue }
    let quizStartTime = null;           // Timestamp when the quiz was started/resumed
    let timerInterval = null;           // Holds the interval ID for the countdown timer
    let quizEndTime = null;             // Calculated target end timestamp for timed quizzes
    let presentationMode = 'all';       // 'all' or 'one-by-one'
    let allowBack = true;               // Whether back navigation is allowed in one-by-one
    let autoSaveInterval = null;        // Holds the interval ID for periodic auto-save
    let submissionInProgress = false;   // Flag to prevent double submissions
    let allQuestionsAnswered = false; // Track overall answered status


    // --- DOM Elements ---
    const quizLoadingDiv = document.getElementById('quizLoading');
    const quizErrorDiv = document.getElementById('quizError');
    const quizContainerDiv = document.getElementById('quizContainer');
    const quizTitleH4 = document.getElementById('quizTitle');
    const quizTimerDiv = document.getElementById('quizTimer');
    const progressTextSpan = document.getElementById('progressText');
    const progressBar = document.getElementById('progressBar');
    const studentInfoDisplayDiv = document.getElementById('studentInfoDisplay');
    const questionAreaDiv = document.getElementById('questionArea');
    const prevButton = document.getElementById('prevButton');
    const nextButton = document.getElementById('nextButton');
    const submitButton = document.getElementById('submitButton');
    const submitSpinner = submitButton ? submitButton.querySelector('.spinner-border') : null;
    console.log("DEBUG: submitButton found:", submitButton);
    console.log("DEBUG: submitSpinner found:", submitSpinner);
    const sessionAttemptId = "{{ session_attempt_id }}"; // <<< Ensure this is passed from view if using session IDs

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', initializeQuiz);

    // Navigation Button Listeners
    // Check if elements exist before adding listeners
    if (prevButton) {
        prevButton.addEventListener('click', () => {
            console.log("DEBUG: Previous Button Clicked!"); // Log click
            navigate(-1);
        });
    } else {
        console.error("Error: Previous button element ('prevButton') not found!");
    }

    if (nextButton) {
        nextButton.addEventListener('click', () => {
            console.log("DEBUG: Next Button Clicked!"); // Log click
            navigate(1);
        });
    } else {
        console.error("Error: Next button element ('nextButton') not found!");
    }

    // Submit Button Listener
    if (submitButton) {
        submitButton.addEventListener('click', () => {
            console.log(">>> DEBUG: Manual Submit Button Clicked! <<<"); // Log click
            submitQuiz(false); // Call submit function, passing false for 'isTimeUp'
        });
    } else {
        console.error("Error: Submit button element ('submitButton') not found!");
    }

    // Cleanup intervals on page leave (unload/close tab)
    window.addEventListener('beforeunload', () => {
        console.log("DEBUG: beforeunload event triggered.");
        // Clear intervals to prevent them running after page context is gone
        if (autoSaveInterval) clearInterval(autoSaveInterval);
        if (timerInterval) clearInterval(timerInterval);
        // Attempt a final save *only if* submission isn't already in progress
        // This helps capture the very last state before closing.
        if (!submissionInProgress) {
            console.log("DEBUG: Attempting final save before unload.");
            saveQuizState();
        }
    });

    console.log("DEBUG: End of script block. All event listeners attached (or attempted)."); // Final confirmation log

    // --- End of Event Listeners Section ---

    // --- Core Functions ---
    /**
     * Initializes the entire quiz taking interface upon page load.
     * - Loads core quiz structure (questions, config, title) from sessionStorage.
     * - Loads student information from sessionStorage.
     * - Checks for a resume flag in sessionStorage.
     * - If resuming, loads the saved state (answers, index, time) from localStorage.
     * - Initializes state variables (answers, current index, timer).
     * - Renders the questions into the DOM.
     * - Restores saved/resumed answers into the form inputs.
     * - Updates the progress bar.
     * - Sets up and starts the timer if applicable.
     * - Calculates the quiz start time (for submission).
     * - Shows the appropriate questions based on presentation mode.
     * - Starts the periodic auto-save interval.
     * - Handles errors during initialization.
     */
    function initializeQuiz() {
        console.log("Initializing quiz for ID:", quizId); // Log start with Quiz ID from template context
        try {
            // --- 1. Load Core Quiz Structure (Always required, from API-3 via STU-1) ---
            console.log("DEBUG: Attempting to load core quiz structure from sessionStorage key:", `quizData_${quizId}`);
            const coreQuizDataString = sessionStorage.getItem(`quizData_${quizId}`);
            if (!coreQuizDataString) {
                // If this fails, the user likely didn't come through the start page correctly.
                throw new Error(`Core quiz data (quizData_${quizId}) not found in session storage. Please start the quiz again via the entry page.`);
            }
            // Parse the JSON string into the global quizData object
            quizData = JSON.parse(coreQuizDataString);
            console.log("DEBUG: Loaded CORE quiz structure from sessionStorage:", quizData);

            // --- 2. Validate Core Quiz Structure ---
            // Perform basic checks to ensure the loaded data is usable.
            if (!quizData || typeof quizData !== 'object') {
                throw new Error("Invalid core quiz data loaded (not an object).");
            }
            if (!quizData.id || !quizData.title || !Array.isArray(quizData.questions)) {
                console.error("DEBUG: Invalid quizData structure:", quizData);
                throw new Error("Loaded core quiz data structure is invalid (missing id, title, or questions array).");
            }
            // Also specifically check if questions is actually an array (JSON parse sometimes yields objects unexpectedly)
            if (!Array.isArray(quizData.questions)) {
                console.error("DEBUG: quizData.questions is not an array:", quizData.questions);
                throw new Error("Loaded core quiz data 'questions' field is not an array.");
            }
            console.log("DEBUG: Core quiz data validated. Number of questions:", quizData.questions.length);


            // --- 3. Check for Resume State ---
            // See if the landing page set a flag indicating we should resume from localStorage.
            const resumeFlagKey = `resumeState_${quizId}`;
            const isResuming = sessionStorage.getItem(resumeFlagKey) === 'true';
            console.log("DEBUG: isResuming:", isResuming);
            // Clean up the flag immediately after checking it, regardless of whether we resume.
            sessionStorage.removeItem(resumeFlagKey);


            // --- 4. Load Student Info (Always required, from STU-1) ---
            console.log("DEBUG: Attempting to load student info from sessionStorage key: quizStudentInfo");
            const storedStudentInfo = sessionStorage.getItem('quizStudentInfo');
            if (!storedStudentInfo) {
                // This shouldn't happen if STU-1 worked, but good to check.
                throw new Error("Student info not found in session storage. Please start the quiz again.");
            }
            // Parse and store in the global state variable. Could be an object or an array (for pairs).
            studentInfo = JSON.parse(storedStudentInfo);
            console.log("DEBUG: Parsed student info from sessionStorage:", studentInfo);


            // --- 5. Apply Saved State (from localStorage if resuming) OR Initialize Fresh State ---
            let savedState = null;          // Holds parsed data from localStorage if resuming
            let remainingTimeSeconds = null;// Time to start timer with (null for fresh start)

            if (isResuming) {
                console.log("DEBUG: Resume required. Attempting to load saved state from localStorage.");
                const storageKey = getLocalStorageKey(); // e.g., quizState_quizId
                const storedStateValue = localStorage.getItem(storageKey);
                if (storedStateValue) {
                    try {
                        savedState = JSON.parse(storedStateValue);
                        console.log("DEBUG: Parsed saved state from localStorage:", savedState);

                        // Apply saved state values to global state variables
                        studentAnswers = savedState.answers || {}; // Restore answers or default to empty
                        currentQuestionIndex = savedState.currentQuestionIndex || 0; // Restore index or default to 0
                        remainingTimeSeconds = savedState.remainingTimeSeconds; // Restore remaining time (could be null if not timed)

                        // Optional: Validate student info in saved state matches current studentInfo?
                        // This adds complexity but ensures the correct student is resuming.
                        // const savedName = savedState.studentInfo?.name?.trim().toLowerCase();
                        // const currentName = (Array.isArray(studentInfo) ? studentInfo[0]?.name : studentInfo?.name)?.trim().toLowerCase();
                        // if (!savedName || !currentName || savedName !== currentName) {
                        //    console.warn("Resuming state student mismatch! Saved:", savedName, "Current:", currentName, ". Resetting state.");
                        //    studentAnswers = {}; currentQuestionIndex = 0; remainingTimeSeconds = null; savedState = null; isResuming = false;
                        // }

                        // Safety check: Ensure restored index is valid for the loaded questions
                        if (currentQuestionIndex >= quizData.questions.length || currentQuestionIndex < 0) {
                            console.warn(`Saved question index ${currentQuestionIndex} out of bounds (0-${quizData.questions.length - 1}), resetting to 0.`);
                            currentQuestionIndex = 0;
                        }
                        console.log("DEBUG: Applied state from localStorage: Index=", currentQuestionIndex, "RemainingSecs=", remainingTimeSeconds);

                    } catch (e) {
                        // Handle error parsing localStorage data - treat as fresh start
                        console.error("Error parsing saved state from localStorage, starting fresh state.", e);
                        localStorage.removeItem(storageKey); // Clear corrupt data
                        studentAnswers = {};
                        currentQuestionIndex = 0;
                        savedState = null; // Ensure savedState is null if parse failed
                        isResuming = false; // Treat as non-resuming now
                    }
                } else {
                    // Resume flag was set, but no data found in localStorage. Strange, but treat as fresh start.
                    console.warn("DEBUG: Resume flag set, but no saved state found in localStorage. Starting fresh state.");
                    studentAnswers = {};
                    currentQuestionIndex = 0;
                    isResuming = false; // Correct the flag
                }
            } else {
                // Not resuming, this is a fresh start
                console.log("DEBUG: Starting fresh quiz state.");
                studentAnswers = {}; // Initialize empty answers
                currentQuestionIndex = 0;
                // remainingTimeSeconds remains null
            }


            // --- 6. Set Configuration (From the fresh quizData loaded from sessionStorage) ---
            presentationMode = quizData.config?.presentation_mode || 'all';
            allowBack = quizData.config?.allow_back !== undefined ? quizData.config.allow_back : true;
            console.log(`DEBUG: Config set: presentationMode=${presentationMode}, allowBack=${allowBack}`);


            // --- 7. Setup UI Elements ---
            console.log("DEBUG: Setting up UI elements.");
            // Set Quiz Title
            quizTitleH4.textContent = quizData.title || 'Quiz';

            // Set Student Name(s) Display
            let nameDisplay = "Unknown";
            if (Array.isArray(studentInfo) && studentInfo.length > 0) {
                nameDisplay = studentInfo.map(s => escapeHTML(s?.name || 'N/A')).join(' & ');
            } else if (typeof studentInfo === 'object' && studentInfo && studentInfo.name) {
                nameDisplay = escapeHTML(studentInfo.name);
            } else {
                console.warn("DEBUG: Student info structure unexpected:", studentInfo);
            }
            studentInfoDisplayDiv.textContent = `Student(s): ${nameDisplay}`;

            // Render the HTML structure for all questions into the question area
            renderQuestions();
            // Populate the rendered inputs with any loaded/resumed answers
            restoreAnswersUI();
            // Set the initial state of the progress bar and text
            updateProgress();
            // Set up and start the timer (using null or remainingTimeSeconds)
            setupTimer(remainingTimeSeconds);
            // Estimate the original start time (less critical, used for final payload)
            quizStartTime = isResuming ? (savedState?.lastSaved ? determineOriginalStartTime(savedState) : Date.now()) : Date.now();
            console.log("DEBUG: Estimated quizStartTime:", new Date(quizStartTime));

            // --- Initial Submit Button State ---
            updateSubmitButtonState(); // <<< SET INITIAL STATE HERE


            // Hide loading spinner and show the main quiz content
            quizLoadingDiv.classList.add('d-none');
            quizContainerDiv.classList.remove('d-none');


            // --- 8. Start Auto-Save Interval ---
            // Ensure any previous interval is cleared before starting a new one
            if (autoSaveInterval) clearInterval(autoSaveInterval);
            // Start saving state periodically (e.g., every 30 seconds)
            autoSaveInterval = setInterval(saveQuizState, 30 * 1000);
            console.log("DEBUG: Auto-save interval started.");


            // --- 9. Display Initial Question(s) and Buttons ---
            if (presentationMode === 'one-by-one') {
                // Show only the question at the current index (could be 0 or resumed index)
                showQuestion(currentQuestionIndex);
                // Set the initial state of navigation buttons
                updateNavigationButtons();
            } else { // 'all' mode
                // Show all question cards at once
                showAllQuestions();
                // Set the initial state of navigation buttons for 'all' mode
                prevButton.style.display = 'none';
                nextButton.style.display = 'none';
                // Enable submit unless submission is already in progress (unlikely here) or no questions
                if (submitButton) {
                    submitButton.style.display = 'inline-block';
                    submitButton.disabled = submissionInProgress || (quizData.questions.length === 0);
                    updateSubmitButtonState(); // Set enabled/disabled based on answers

                }
            }
            console.log("DEBUG: Initialization complete. UI should be ready.");

        } catch (error) {
            // Catch any error during the entire initialization process
            console.error("FATAL Error during quiz initialization:", error);
            quizLoadingDiv.classList.add('d-none'); // Hide loading
            quizErrorDiv.textContent = `Error initializing quiz: ${error.message}. Please try starting the quiz again.`;
            quizErrorDiv.classList.remove('d-none'); // Show error
            quizContainerDiv.classList.add('d-none'); // Hide the main container on critical error
            // Stop any potential intervals if they somehow started
            if (autoSaveInterval) clearInterval(autoSaveInterval);
            if (timerInterval) clearInterval(timerInterval);
        }
    } // End initializeQuiz



    /**
     * Renders all question cards into the questionAreaDiv based on quizData.
     * Initially hides them if mode is one-by-one.
     */
    function renderQuestions() {
        console.log("DEBUG: renderQuestions called.");
        questionAreaDiv.innerHTML = '';
        if (!quizData || !quizData.questions || quizData.questions.length === 0) { /* ... handle no questions ... */ return; }

        const mediaUrlPrefix = "/media_files/";

        quizData.questions.forEach((q, index) => {
            const card = document.createElement('div');
            card.classList.add('card', 'question-card'); // Removed shadow-sm, using default shadow
            card.dataset.questionId = q.id;
            card.dataset.index = index;
            card.style.display = 'none';

            let optionsHtml = '';
            let questionTextHtml = escapeHTML(q.text || '');

            if (q.type === 'MCQ') {
                const isSingleChoice = q.mcq_is_single_choice === true;
                const inputType = isSingleChoice ? 'radio' : 'checkbox';
                const inputName = `q_${q.id}`; // Common name for radio group

                optionsHtml = `<div class="question-options d-flex flex-wrap justify-content-center align-items-stretch list-group list-group-flush">`; // Use list-group for text, flex overrides

                (q.options || []).forEach(opt => {
                    if (!opt || typeof opt !== 'object') return;
                    const optionId = opt.id;
                    const optionText = opt.text;
                    const optionMediaFilename = opt.media_filename;
                    if (!optionId || (!optionText && !optionMediaFilename)) return;

                    const inputId = `q_${q.id}_opt_${opt.id}`;
                    const hasImage = !!optionMediaFilename;
                    const hasText = !!optionText;

                    if (hasImage) {
                        // --- Structure for IMAGE options ---
                        let optionContent = `<img src="${mediaUrlPrefix}${escapeHTML(optionMediaFilename)}" alt="${escapeHTML(optionText || 'Option Image')}" class="mcq-option-image">`;
                        if (hasText) { optionContent += `<div class="option-text">${escapeHTML(optionText)}</div>`; }

                        optionsHtml += `
                        <div class="mcq-option-image-item">
                            <label for="${inputId}">
                                ${optionContent}
                            </label>
                            <input class="form-check-input mcq-option visually-hidden"
                                   type="${inputType}" name="${inputName}" value="${escapeHTML(String(optionId))}"
                                   id="${inputId}" data-question-id="${q.id}"
                                   onchange="saveAnswer(this); handleMcqSelectionStyle(this);">
                        </div>
                    `;
                    } else {
                        // --- Structure for TEXT options ---
                        optionsHtml += `
                        <label class="list-group-item" for="${inputId}">
                            <input class="form-check-input me-2 mcq-option"
                                   type="${inputType}" name="${inputName}" value="${escapeHTML(String(optionId))}"
                                   id="${inputId}" data-question-id="${q.id}"
                                   onchange="saveAnswer(this);">
                            ${escapeHTML(optionText)}
                        </label>
                    `;
                    }
                });
                optionsHtml += '</div>'; // End flex container / list-group

            } else if (q.type === 'SHORT_TEXT') {
                const inputId = `q_${q.id}_ans`;
                optionsHtml = `
                 <div class="question-options px-3"> {# Add some padding #}
                     <label for="${inputId}" class="form-label">Your Answer:</label>
                     <textarea class="form-control short-text-answer" id="${inputId}" rows="3"
                               data-question-id="${q.id}" oninput="saveAnswer(this)"
                               placeholder="Enter your answer here..."></textarea>
                 </div>`;
            } else if (q.type === 'MEDIA') {
                optionsHtml = `<div class="question-options text-center px-3"><img src="${escapeHTML(q.media_url || '#')}" class="img-fluid rounded" alt="Question Media" style="max-height: 300px;"></div>`;
                optionsHtml += `<p class="text-muted mt-2 px-3">Please answer based on the media shown.</p>`;
            } else {
                optionsHtml = '<p class="text-muted question-options px-3">Unsupported question type.</p>';
            }

            // --- Include Main Question Media ---
            let questionMediaHtml = '';
            if (q.media_filename) {
                questionMediaHtml = `<div class="question-media mb-3 text-center px-3"><img src="${mediaUrlPrefix}${escapeHTML(q.media_filename)}" class="img-fluid rounded" alt="Question Media" style="max-height: 250px;"></div>`;
            }

            // --- Assemble Card ---
            // Removed card-title class from h5, added custom style in CSS
            card.innerHTML = `
            <div class="card-body">
                <h5 class="mb-3">Question ${index + 1}: <span class="question-text">${questionTextHtml}</span></h5>
                ${questionMediaHtml}
                ${optionsHtml}
            </div>
        `;
            questionAreaDiv.appendChild(card);
        }); // End forEach question

        // Remove previous style handler? Add new one.
        // Make sure handleMcqSelectionStyle is correctly defined and attached if needed for image options
        // questionAreaDiv.removeEventListener('change', handleMcqSelectionStyle); // Remove old if exists
        questionAreaDiv.addEventListener('change', handleMcqSelectionStyle); // Add/Re-add listener

    } // End renderQuestions

    function handleMcqSelectionStyle(eventOrInput) {
        let targetInput;
        if (eventOrInput.target && eventOrInput.target.classList.contains('mcq-option')) {
            targetInput = eventOrInput.target;
        } else if (eventOrInput.classList && eventOrInput.classList.contains('mcq-option')) {
            targetInput = eventOrInput;
        } else {
            return;
        }

        const questionCard = targetInput.closest('.question-card');
        if (!questionCard) return;

        // Find all image option containers within this question card
        const imageOptionContainers = questionCard.querySelectorAll('.mcq-option-image-item');

        imageOptionContainers.forEach(container => {
            const input = container.querySelector('input.mcq-option');
            if (input) {
                if (input.checked) {
                    container.classList.add('border-primary');
                } else {
                    container.classList.remove('border-primary');
                }
            }
        });
    }

    /**
     * NEW (or ensure exists): Style selected options on initial load/resume.
     */
    /**
   * Updates restoreAnswersUI to trigger style update
   */
    function restoreAnswersUI() {
        console.log("DEBUG: Restoring answers to UI:", studentAnswers);
        Object.keys(studentAnswers).forEach(questionId => {
            const answer = studentAnswers[questionId];
            const questionCard = questionAreaDiv.querySelector(`.question-card[data-question-id="${questionId}"]`);
            if (!questionCard) return;

            if (Array.isArray(answer)) { // MCQ answer
                answer.forEach(optionId => {
                    const input = questionCard.querySelector(`input.mcq-option[value="${optionId}"]`);
                    if (input) {
                        input.checked = true;
                        // Trigger style update specifically for this input
                        handleMcqSelectionStyle(input);
                    }
                });
            } else if (typeof answer === 'string') { // Short Text
                const textarea = questionCard.querySelector(`textarea[data-question-id="${questionId}"]`);
                if (textarea) textarea.value = answer;
            }
        });
        console.log("DEBUG: Finished restoring answers to UI.");
    }

    /**
     * Shows only the question card at the specified index.
     * @param {number} index - The index of the question to show.
     */
    function showQuestion(index) {
        console.log("DEBUG: showQuestion called for index:", index);
        const cards = questionAreaDiv.querySelectorAll('.question-card');
        cards.forEach((card, i) => {
            card.style.display = (i === index) ? 'block' : 'none';
        });
    }

    /**
     * Shows all question cards (for 'all' presentation mode).
     */
    function showAllQuestions() {
        console.log("DEBUG: showAllQuestions called.");
        const cards = questionAreaDiv.querySelectorAll('.question-card');
        cards.forEach(card => {
            card.style.display = 'block';
        });
    }

    /**
     * Saves the current value of an answer input to the studentAnswers state object
     * and triggers saving the state to localStorage.
     * @param {HTMLElement} inputElement - The input/textarea/checkbox element that changed.
     */
    function saveAnswer(inputElement) {
        if (!inputElement || !inputElement.dataset || submissionInProgress) return; // Don't save if submitting
        const questionId = inputElement.dataset.questionId;
        if (!questionId) return;

        let answer;
        const questionCard = inputElement.closest('.question-card');
        const questionOptionsDiv = questionCard ? questionCard.querySelector('.question-options') : null;

        if (inputElement.type === 'checkbox' || inputElement.type === 'radio') {
            if (!questionOptionsDiv) return;
            const checkedOptions = questionOptionsDiv.querySelectorAll(`input[name="q_${questionId}"]:checked`);
            answer = Array.from(checkedOptions).map(cb => cb.value);
        } else if (inputElement.tagName === 'TEXTAREA') {
            answer = inputElement.value; // Store trimmed? No, store raw input for now.
        } else {
            return; // Unsupported type
        }

        studentAnswers[questionId] = answer;
        // console.log("Saved Answer for", questionId, ":", answer); // Can be noisy
        saveQuizState(); // Trigger save
        updateSubmitButtonState(); // <<< ADD THIS CALL

    }

    /**
     * Handles clicks on Previous/Next buttons.
     * @param {number} direction - +1 for Next, -1 for Previous.
     */
    function navigate(direction) {
        console.log("DEBUG: navigate called with direction:", direction);
        if (submissionInProgress) return; // Prevent navigation while submitting

        const newIndex = currentQuestionIndex + direction;
        const totalQuestions = quizData?.questions?.length || 0;

        if (newIndex >= 0 && newIndex < totalQuestions) {
            currentQuestionIndex = newIndex;
            showQuestion(currentQuestionIndex);
            updateProgress();
            updateNavigationButtons();
            saveQuizState(); // Save state after navigating index
        } else {
            console.warn("DEBUG: Navigation blocked (out of bounds). Index:", newIndex);
        }
    }

    /**
     * Updates the visibility and enabled state of Prev/Next/Submit buttons
     * based on the current question index and quiz configuration.
     */
    function updateNavigationButtons() {
        if (!quizData || !quizData.questions || presentationMode !== 'one-by-one') {
            // Hide all nav if not one-by-one or no questions
            prevButton.style.display = 'none';
            nextButton.style.display = 'none';
            submitButton.style.display = presentationMode === 'all' ? 'inline-block' : 'none';
            if (submitButton) submitButton.disabled = submissionInProgress || (quizData.questions.length === 0); // Disable submit if no questions
            return;
        }

        const totalQuestions = quizData.questions.length;

        // Previous Button
        if (currentQuestionIndex > 0 && allowBack) {
            prevButton.style.display = 'inline-block';
            prevButton.disabled = submissionInProgress;
        } else {
            prevButton.style.display = 'none';
        }

        // Next/Submit Button
        if (currentQuestionIndex === totalQuestions - 1) {
            // Last question
            nextButton.style.display = 'none';
            submitButton.style.display = 'inline-block';
            submitButton.disabled = submissionInProgress;
            updateSubmitButtonState(); // <<< UPDATE SUBMIT STATE HERE TOO

        } else {
            nextButton.style.display = 'inline-block';
            nextButton.disabled = submissionInProgress;
            submitButton.style.display = 'none';
        }
    }

    /**
     * Updates the progress bar and text display.
     */
    function updateProgress() {
        const totalQuestions = quizData?.questions?.length || 0;
        // Ensure currentQuestionIndex is valid before calculating percentage
        const currentValidIndex = Math.min(Math.max(0, currentQuestionIndex), totalQuestions > 0 ? totalQuestions - 1 : 0);
        const currentQNumber = totalQuestions > 0 ? currentValidIndex + 1 : 0; // 1-based for display
        const percent = totalQuestions > 0 ? Math.round((currentQNumber / totalQuestions) * 100) : 0;

        progressTextSpan.textContent = `Question ${currentQNumber} of ${totalQuestions}`;
        progressBar.style.width = `${percent}%`;
        progressBar.setAttribute('aria-valuenow', percent);
    }

    /**
     * Sets up and starts the countdown timer if configured.
     * @param {number|null} resumeSeconds - Remaining seconds if resuming, null otherwise.
     */
    function setupTimer(resumeSeconds = null) {
        const durationMinutes = quizData?.config?.duration;
        quizEndTime = null; // Reset end time
        if (timerInterval) clearInterval(timerInterval); // Clear previous interval
        timerInterval = null;

        let startTimeSeconds = null;
        if (resumeSeconds !== null && resumeSeconds >= 0) {
            startTimeSeconds = resumeSeconds;
        } else if (durationMinutes && durationMinutes > 0) {
            startTimeSeconds = durationMinutes * 60;
        }

        if (startTimeSeconds === null || startTimeSeconds <= 0) {
            quizTimerDiv.style.display = 'none';
            return; // No timer needed
        }

        quizEndTime = Date.now() + startTimeSeconds * 1000;
        let timeLeftSeconds = startTimeSeconds;

        quizTimerDiv.style.display = 'block';
        quizTimerDiv.classList.remove('text-warning', 'text-danger');
        updateTimerDisplay(timeLeftSeconds);

        console.log(`DEBUG: Timer setup. Start seconds: ${startTimeSeconds}, End time: ${new Date(quizEndTime)}`);

        timerInterval = setInterval(() => {
            const now = Date.now();
            timeLeftSeconds = Math.max(0, Math.round((quizEndTime - now) / 1000));
            updateTimerDisplay(timeLeftSeconds);

            if (timeLeftSeconds <= 0) {
                clearInterval(timerInterval);
                timerInterval = null;
                quizTimerDiv.textContent = "Time's Up!";
                quizTimerDiv.classList.remove('text-danger');
                quizTimerDiv.classList.add('text-warning');
                console.log("Time expired. Auto-submitting quiz.");
                if (!submissionInProgress) submitQuiz(true); // Auto-submit
            } else if (timeLeftSeconds < 60) {
                quizTimerDiv.classList.add('text-danger');
            } else {
                quizTimerDiv.classList.remove('text-danger');
            }
        }, 1000);
    }

    /**
     * Updates the timer display in MM:SS format.
     * @param {number} seconds - Total seconds remaining.
     */
    function updateTimerDisplay(seconds) {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        quizTimerDiv.textContent = `${minutes}:${remainingSeconds < 10 ? '0' : ''}${remainingSeconds}`;
    }

    /**
     * Gathers submission data, calls the submit API (API-4), handles the response,
     * clears saved state, and redirects to the results page (STU-3).
     * @param {boolean} [isTimeUp=false] - Flag indicating if submission is due to timer expiry.
     */
    async function submitQuiz(isTimeUp = false) {
        console.log(`>>> DEBUG: submitQuiz called. Current submissionInProgress: ${submissionInProgress}. Time up: ${isTimeUp}`);
        if (submissionInProgress) {
            console.log(">>> DEBUG: Submission already in progress, ignoring submit call.");
            return;
        }

        // --- ADD CHECK: Bypass answer check only if time is up ---
        if (!isTimeUp && !checkAllQuestionsAnswered()) {
            console.warn("DEBUG: Manual submit attempted but not all questions answered.");
            alert("Please answer all questions before submitting.");
            return; // Prevent manual submission
        }
        // --- END CHECK ---

        submissionInProgress = true;
        console.log(">>> DEBUG: Set submissionInProgress = true");
        console.log("DEBUG: submitQuiz called. Time up:", isTimeUp);
        setButtonState(true); // Disable nav/submit buttons and show spinner

        if (timerInterval) clearInterval(timerInterval); // Stop timer
        if (autoSaveInterval) clearInterval(autoSaveInterval); // Stop auto-save

        const startTimeISO = quizStartTime ? new Date(quizStartTime).toISOString() : null;
        const endTimeISO = new Date(Date.now()).toISOString();

        const submissionData = {
            student_info: studentInfo, // <<< Send the studentInfo object/array loaded during init
            answers: studentAnswers,
            start_time: startTimeISO,
            end_time: endTimeISO,
            submitted_due_to_timeout: isTimeUp
        };
        console.log("Submission Payload (to send to API-4):", submissionData);

        const apiUrl = `/api/quizzes/${quizId}/submit/`;
        const csrfToken = getCookie('csrftoken'); // Get CSRF if needed

        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    // 'X-CSRFToken': csrfToken // Include if backend API requires CSRF for this endpoint
                },
                body: JSON.stringify(submissionData)
            });

            const data = await response.json();
            console.log("Submission Response Status:", response.status);
            console.log("Submission Response Data:", data);

            if (response.ok) {
                // --- Success ---
                clearSavedState(); // Clear localStorage

                // Store attempt data for results page
                try {
                    sessionStorage.removeItem(`quizData_${quizId}`);
                    sessionStorage.setItem('quizAttemptData', JSON.stringify(data));
                    sessionStorage.setItem('lastAttemptId', data.attempt_id);
                } catch (e) {
                    console.error("Session storage error after submission:", e);
                }

                // Redirect to results page (STU-3)
                const resultsUrl = `/quiz/results/${data.attempt_id}/`;
                console.log("Redirecting to results page:", resultsUrl);
                window.location.href = resultsUrl; // Redirect

            } else {
                // --- API Error Handling ---
                console.error("Submission failed API response:", data);
                alert(`Error submitting quiz: ${data.error || 'Please try again.'}`);
                setButtonState(false); // Re-enable buttons on API error
                submissionInProgress = false; // Reset flag
                // Restart auto-save?
                console.log(">>> DEBUG: Reset submissionInProgress = false due to API error.");
                if (!autoSaveInterval) autoSaveInterval = setInterval(saveQuizState, 30 * 1000);
            }

        } catch (error) {
            // --- Network/JS Error Handling ---
            console.error("Network or other error submitting quiz:", error);
            alert("Network error submitting quiz. Please check your connection and try again.");
            setButtonState(false); // Re-enable buttons
            submissionInProgress = false; // Reset flag
            console.log(">>> DEBUG: Reset submissionInProgress = false due to catch block error.");
            if (!autoSaveInterval) autoSaveInterval = setInterval(saveQuizState, 30 * 1000);
        }
    } // End submitQuiz


    // --- Auto-Save Logic ---

    /**
     * Gets the localStorage key specific to this quiz attempt.
     */
    function getLocalStorageKey() {
        return `${LOCAL_STORAGE_KEY_PREFIX}${quizId}`;
    }

    /**
     * Saves the current quiz state (answers, index, time) to localStorage.
     */
    function saveQuizState() {
        if (!quizData || !studentInfo || submissionInProgress) return; // Don't save if not initialized or submitting

        let remainingTime = null;
        if (timerInterval && quizEndTime) {
            const now = Date.now();
            remainingTime = Math.max(0, Math.round((quizEndTime - now) / 1000));
        }

        const stateToSave = {
            // Storing minimal state needed to resume
            studentInfo: studentInfo,
            answers: studentAnswers,
            currentQuestionIndex: currentQuestionIndex,
            remainingTimeSeconds: remainingTime,
            lastSaved: Date.now()
        };

        try {
            const key = getLocalStorageKey();
            localStorage.setItem(key, JSON.stringify(stateToSave));
            // console.log("DEBUG: Quiz state saved to localStorage."); // Reduce noise
        } catch (e) {
            console.error("Error saving quiz state to localStorage:", e);
            if (autoSaveInterval) {
                clearInterval(autoSaveInterval);
                autoSaveInterval = null;
                alert("Warning: Could not save quiz progress. Local storage might be full or disabled. Auto-save stopped.");
            }
        }
    }

    // --- Helper Functions ---

    /**
     * Basic HTML escaping function.
     */
    function escapeHTML(str) {
        if (str === null || str === undefined) return '';
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
    }

    /**
     * Updates the disabled state of navigation/submit buttons and shows/hides
     * the spinner on the submit button.
     * @param {boolean} isLoading - True to disable buttons/show spinner, false otherwise.
     */
    // --- REVISED setButtonState ---
    function setButtonState(isLoading) {
        // Update main loading flag
        submissionInProgress = isLoading; // Assume call to setButtonState implies loading state change

        // Always disable Prev/Next during submit process
        if (prevButton) prevButton.disabled = isLoading;
        if (nextButton) nextButton.disabled = isLoading;

        // Handle Submit button state
        if (submitButton) {
            // Check answered status *unless* we are currently loading (submitting)
            const allowSubmit = isLoading ? false : checkAllQuestionsAnswered();
            submitButton.disabled = !allowSubmit;
            console.log(`DEBUG: setButtonState(${isLoading}) -> Submit button disabled: ${submitButton.disabled}`);

            if (submitSpinner) {
                if (isLoading) {
                    submitSpinner.classList.remove('d-none');
                } else {
                    submitSpinner.classList.add('d-none');
                }
            }
        }
    }

    /**
     * Helper function to get CSRF token from cookies (if needed).
     */
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    /**
     * Gets the localStorage key specific to this quiz attempt.
     */
    function getLocalStorageKey() {
        // Enhance later with student ID if multi-student safety needed on same browser
        return `${LOCAL_STORAGE_KEY_PREFIX}${quizId}`;
    }

    /**
     * Clears the saved quiz state from localStorage.
     */
    function clearSavedState() {
        try {
            const key = getLocalStorageKey();
            localStorage.removeItem(key);
            console.log("DEBUG: Cleared saved quiz state from localStorage. Key:", key);
        } catch (e) {
            console.error("Error clearing saved quiz state:", e);
        }
    }

    /**
     * Tries to estimate the original start time based on saved state.
     * Used for informational purposes or potentially more accurate time tracking.
     * @param {object} savedState - The state object loaded from localStorage.
     * @returns {number} - Estimated start timestamp (milliseconds since epoch) or current time as fallback.
     */
    function determineOriginalStartTime(savedState) {
        // Check if quizData and config are loaded before accessing duration
        if (!savedState || !savedState.lastSaved || !quizData?.config?.duration) {
            return Date.now(); // Fallback to now
        }
        try {
            const durationSeconds = quizData.config.duration * 60;
            // Use ?? 0 for remainingSeconds in case it's null/undefined in saved state
            const remainingSeconds = savedState.remainingTimeSeconds ?? durationSeconds;
            const elapsedSeconds = durationSeconds - remainingSeconds;
            // Ensure elapsedSeconds isn't negative if remaining > duration (data issue)
            const safeElapsedSeconds = Math.max(0, elapsedSeconds);
            return savedState.lastSaved - (safeElapsedSeconds * 1000);
        } catch (e) {
            console.error("Error determining original start time:", e);
            return Date.now(); // Fallback
        }
    }

    /**
     * Shows an error message in the designated error div.
     * @param {string} message - The error message to display.
     */
    function showError(message) {
        if (quizErrorDiv) { // Check if element exists
            quizErrorDiv.textContent = message;
            quizErrorDiv.classList.remove('d-none');
        } else {
            console.error("Error display element not found. Message:", message);
        }
    }

    /**
     * Clears any currently displayed error messages.
     */
    function clearMessages() { // Renamed from clearError for potentially adding success msgs later
        if (quizErrorDiv) {
            quizErrorDiv.classList.add('d-none');
            quizErrorDiv.textContent = '';
        }
        // Add similar logic for success messages if you have a success message div
    }

    /**
     * Shows/hides the main quiz container div.
     * @param {boolean} show - True to show, false to hide.
     */
    function showFormContent(show) { // Renamed for consistency if used elsewhere
        if (quizContainerDiv) {
            if (show) { quizContainerDiv.classList.remove('d-none'); }
            else { quizContainerDiv.classList.add('d-none'); }
        }
    }

    /**
     * Shows/hides the main loading spinner.
     * @param {boolean} show - True to show, false to hide.
     */
    function showLoadingSpinner(show) {
        if (quizLoadingDiv) {
            if (show) { quizLoadingDiv.classList.remove('d-none'); }
            else { quizLoadingDiv.classList.add('d-none'); }
        }
    }


    /**
     * Checks if all questions currently loaded in quizData have a valid and meaningful
     * answer entry in the studentAnswers object based on question type.
     * - MCQ: Requires at least one option selected.
     * - SHORT_TEXT: Requires the answer string not be empty after trimming whitespace.
     * - Other types: Currently assumed answered if any entry exists.
     * @returns {boolean} True if all questions have a valid answer, false otherwise.
     */
    function checkAllQuestionsAnswered() {
        // Ensure necessary data structures are available
        if (!quizData || !quizData.questions || !Array.isArray(quizData.questions) || quizData.questions.length === 0) {
            console.log("DEBUG CheckAnswered: Quiz data or questions array is missing or empty.");
            return false; // Cannot determine if all are answered if there are no questions or data is invalid
        }

        const totalQuestions = quizData.questions.length;
        let answeredCount = 0; // Counter for questions considered answered

        console.log("DEBUG CheckAnswered: Starting check for", totalQuestions, "questions.");

        // Iterate through each question defined in the quiz structure
        for (const question of quizData.questions) {
            const questionId = question.id; // Get the ID for lookups and logging
            const questionType = question.type; // Get the type for specific checks
            const answer = studentAnswers[questionId]; // Get the student's answer from state
            let isConsideredAnswered = false; // Flag for the current question

            // First, check if an answer entry exists at all (key is present and value is not undefined/null)
            if (studentAnswers.hasOwnProperty(questionId) && answer !== undefined && answer !== null) {

                // Apply type-specific logic to determine if the existing answer counts as "answered"
                switch (questionType) {
                    case 'MCQ':
                        // For Multiple Choice, check if the answer is an array and has at least one selected option ID.
                        isConsideredAnswered = Array.isArray(answer) && answer.length > 0;
                        // Log details specific to MCQ check
                        // console.log(`DEBUG CheckAnswered: MCQ [${questionId}] | Answer: ${JSON.stringify(answer)} | Is Array: ${Array.isArray(answer)} | Length > 0: ${Array.isArray(answer) && answer.length > 0} | Result: ${isConsideredAnswered}`);
                        break;

                    case 'SHORT_TEXT':
                        // For Short Text, check if the answer is a string and not just whitespace.
                        isConsideredAnswered = typeof answer === 'string' && answer.trim().length > 0;
                        // Log details specific to Short Text check
                        // console.log(`DEBUG CheckAnswered: SHORT_TEXT [${questionId}] | Answer: "${answer}" | Is String: ${typeof answer === 'string'} | Trimmed Length > 0: ${typeof answer === 'string' && answer.trim().length > 0} | Result: ${isConsideredAnswered}`);
                        // Note: If submitting an empty string IS considered a valid answer, change this to:
                        // isConsideredAnswered = typeof answer === 'string';
                        break;

                    // Add cases for other question types here if they have specific "answered" criteria
                    // case 'MEDIA':
                    //     // How is media answered? If it always pairs with another type, maybe no check needed here?
                    //     // If it requires interaction (e.g., clicking something), check for that interaction state.
                    //     isConsideredAnswered = true; // Placeholder: Assume answered if key exists
                    //     break;

                    default:
                        // For unknown or simple types, consider any non-null/undefined entry as answered.
                        isConsideredAnswered = true;
                        // console.log(`DEBUG CheckAnswered: Default Type [${questionId}] | Answer: ${answer} | Result: ${isConsideredAnswered}`);
                        break;
                }
            } else {
                // Log if no entry was found for this question ID
                // console.log(`DEBUG CheckAnswered: No answer entry found for Q [${questionId}]`);
                isConsideredAnswered = false;
            }

            // If the question is considered answered according to its type's logic, increment count
            if (isConsideredAnswered) {
                answeredCount++;
            }
        } // End loop through questions

        // Final log and result
        console.log(`DEBUG CheckAnswered: Final Count - Answered: ${answeredCount} / Total: ${totalQuestions}`);
        return answeredCount === totalQuestions; // Return true only if all questions met their answered criteria
    }



    function updateSubmitButtonState() {
        if (!submitButton) return; // Safety check

        allQuestionsAnswered = checkAllQuestionsAnswered(); // Update global flag
        // Enable submit only if NOT currently submitting AND all questions have an answer entry
        submitButton.disabled = submissionInProgress || !allQuestionsAnswered;
        console.log(`DEBUG: Submit button disabled: ${submitButton.disabled} (submissionInProgress: ${submissionInProgress}, allAnswered: ${allQuestionsAnswered})`);
    }



</script>
{% endblock %}